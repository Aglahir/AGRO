using System;
using Newtonsoft.Json;
using AGRO_GRAMM;
using System.Collections.Generic;


COMPILER PROGRAM

const int // types
	  undef = 0, t_int = 1, t_float = 2, t_char = 3, t_void = 4 ,t_obj = 5, t_string = 6;

const int // object kinds
	  var = 0, func = 1, temporal = 2;


int[] TERM_OPERATORS = { _mul, _div };
int[] EXP_OPERATORS = { _add, _sub };
int[] RELEXP_OPERATORS = { _and, _or };
int[] RELOP_OPERATORS = { _greater, _less, _greatereq, _lesseq, _equaleq, _different };
Dictionary<int, string> operandInts = JsonConvert.DeserializeObject<Dictionary<int, string>>(String.Format(@"{
                        {0}:'+',
                        {1}:'-',
                        {2}:'/',
                        {3}:'*',
                        {4}:'<',
                        {5}:'<=',
                        {6}:'>',
                        {7}:'>=',
                        {8}:'==',
                        {9}:'=',
                        {10}:'!=',
                        {11}:'&&',
                        {12}:'and',
                        {13}:'or',
                        {14}:'||'
            }", 
            _add, 
            _sub, 
            _div, 
            _mul, 
            _less, 
            _lesseq, 
            _greater,
            _greatereq,
            _equaleq,
            _equal,
            _different,
            _and,
            _and,
            _or,
            _or
            ));
SymbolTable   sTable;

Stack<String>   stackOperand = new Stack<String>();
Stack<int>   stackOperator = new Stack<int>();
Stack<int>      stackTypes = new Stack<int>();

int tempCont = 0;

List<Actions> program = new List<Actions>();


string createTempInt(int tempp, SymbolTable st){
    string tempName;
    tempName = "_t" + tempCont;
    tempCont+=1;
    st.putSymbol(tempName, t_int, temporal);
    return tempName;
}

string createTempFloat(float tempp, SymbolTable st){
    string tempName;
    tempName = "_t" + tempCont;
    tempCont+=1;
    st.putSymbol(tempName, t_float, temporal);
    return tempName;
}

string createTempString(string tempp, SymbolTable st){
    string tempName;
    tempName = "_t" + tempCont;
    tempCont+=1;
    st.putSymbol(tempName, t_string, temporal);
    return tempName;
}

bool isIn(string space, char element){
    int i = 0;
    while(i < space.Length){
        if(element == space[i]){
            return true;        
        }
        i++;
    }
    return false;
}

void check(SymbolTable st, int[] arr){
    string leftOper;
    string rightOper;
    int leftType;
    int rightType;
    int operat;
    string tempName;
    if(stackOperator.Count > 0){
        if(Array.Exists(arr, s => s.Equals(stackOperator.Peek()) )){
            // Get the data to create the quad
            rightType = stackTypes.Pop();
            rightOper = stackOperand.Pop();
            leftType = stackTypes.Pop();
            leftOper = stackOperand.Pop();
            operat = stackOperator.Pop();
            // Create the temporal variable
            tempName = "_t" + tempCont;
            tempCont+=1;
            Cuadruple quad = new Cuadruple(operat, leftOper, rightOper, "t1", st, operandInts);
            st.putSymbol(tempName, quad.typeOut, temporal);
            program.Add(quad);
        }
    }
}

/*--------------------------------------------------------------------------*/    

bool IsFunctionCall(){
    scanner.ResetPeek();
    Token x = la; 
    while (x.kind == _id ) 
        x = scanner.Peek();
    return x.kind == _pl;
}

bool IsMethodCall() { 
    scanner.ResetPeek();
    Token x = la; 
    while (x.kind == _id || x.kind == _dot) 
        x = scanner.Peek();
    return x.kind == _pl;
} 

bool IsTypeFunction() {
    scanner.ResetPeek();
    Token next = scanner.Peek();
    next = scanner.Peek();
    return next.kind == _pl;
}

bool IsDecVars(){
    scanner.ResetPeek();
    Token x = scanner.Peek();
    while (x.kind == _id || x.kind == _comma) 
        x = scanner.Peek();
    return x.kind == _semicolon;
}

CHARACTERS

letter		= 'A'..'Z' + 'a'..'z'.
digit		= '0'..'9'.
tab			= '\t'.
cr			= '\r'.
lf			= '\n'.
newLine		= cr + lf.
notQuote	= ANY - '"' - "\r\n".

TOKENS

id			= letter { letter | digit }.
cte_I		= digit { digit }.
cte_F		= digit { digit } "." digit { digit }.
ctr_Str 	= '"' {notQuote} '"'.
cbl         = "{".
cbr         = "}".
bl          = "[".
br          = "]".
pl          = "(".
pr          = ")".
comma       = ",".
semicolon   = ";".
add         = "+".
sub         = "-".
mul         = "*".
div         = "/".
equal       = "=".
dot         = ".".
sadd        = "+=".
ssub        = "-=".
sdiv        = "/=".
smul        = "*=".
increment   = "++".
decrement   = "--".
colon       = ":".
less        = "<".
greater     = ">".
lesseq      = "<=".
greatereq   = ">=".
equaleq     = "==".
different   = "!=".
and         = "&&".
or          = "||".

COMMENTS FROM "%%" TO "\r\n"

IGNORE tab + cr + lf

PRODUCTIONS

PROGRAM= 
    (.
     sTable = new SymbolTable();
    .)
    { DECLARATION } MAIN
    
.

DECLARATION=
    
    IF( IsTypeFunction() ) DEC_FUNC | DEC_VARS //| DEC_CLASS
.

DEC_VARS                                    (. string name; int type; string className; .)
=
    ( IDENT		    < out className >
    IDENT                   < out name >    (. sTable.putSymbol(name, t_obj, var); .)
    { comma IDENT           < out name >    (. sTable.putSymbol(name, t_obj, var); .)   
    } semicolon ) |
    ( 
     SIMPLE_TYPE            < out type >
     IDENT                  < out name >    (. sTable.putSymbol(name, type, var); .)
     [ bl cte_I br [ bl cte_I br ] ] 
     { comma IDENT         < out name >     (. sTable.putSymbol(name, type, var); .)
     [ bl cte_I br [ bl cte_I br ] ] } 
     semicolon 
    )
.

DEC_FUNC				(. string name; int type; .)
=				
    TYPE_FUNC			< out type >
    IDENT			< out name > (. sTable.putSymbol(name, type, func);
                                    sTable = sTable.newChildSymbolTable(); .)
    pl [ PARAMS_FUNC ] pr
    cbl [
     ( IF( IsDecVars() ) DEC_VARS |
      STATUTE ) 
      { ( IF( IsDecVars() ) DEC_VARS |
       STATUTE ) } ] 
     [ RETURN ] 
    cbr					(. sTable = sTable.parentSymbolTable; .)
.
/*
DEC_CLASS=
    "class" IDENT
    [ colon IDENT ] 
    cbl { CLASS_DEF } cbr
.

COMPOUND_TYPE  < out int typeObj >  (. string type; .) 
=
    IDENT       < out type >	(. typeObj = t_obj; .)
.
*/
SIMPLE_TYPE         < out int type >
=                   (. type = undef; .) 
    (
    "int"           (. type = t_int; .)   |
    "float"         (. type = t_float; .) |
    "char"          (. type = t_char; .)
    )
.

MAIN=               (. sTable = sTable.newChildSymbolTable(); .)
    "main" cbl ( IF( IsDecVars() ) DEC_VARS | STATUTE ) { IF( IsDecVars() ) DEC_VARS | STATUTE } cbr
                    (. sTable = sTable.parentSymbolTable; .)
.

STATUTE=
    INPUT       |
    PRINT       |
    IF( IsFunctionCall() ) FUNC_CALL  |
 //   IF( IsMethodCall() ) METHOD_CALL  |
    CONDITIONAL |
    WHILE       |
    FOR         |
    ASSIGN      
.

TYPE_FUNC           < out int type >
=                   (. type = undef; .)
    (
        "int"       (. type = t_int; .)     | 
        "float"     (. type = t_float; .)   |
        "char"      (. type = t_char; .)    |
        "void"      (. type = t_void; .)
    )
.

PARAMS_FUNC             		(. string name; int type; .)
=
    SIMPLE_TYPE         < out type >
    IDENT		< out name >	(. sTable.putSymbol(name, type, var); .)
    { 
     comma SIMPLE_TYPE	< out type >
     IDENT		< out name >	(. sTable.putSymbol(name, type, var); .)
    }
.

RETURN=
    "return" EXP semicolon
.

EXP=
    TERM                    (. check(sTable, EXP_OPERATORS); .)
    { (add (. stackOperator.Push(_add); .) | sub (. stackOperator.Push(_sub);.) ) TERM }
.
/*
CLASS_DEF=
    ( "+" | "-" ) ( IF( IsTypeFunction() ) DEC_FUNC | DEC_VARS )
.
*/
ASSIGN=
    VARIABLE_ASSIGN ( ( ( SHORT_ASSIGN | equal ) EXP ) | STEP ) semicolon
.

INPUT=
    "input" pl VARIABLE_ASSIGN pr semicolon
.

PRINT=
    "print" pl  EXP { comma EXP } pr semicolon
.

CONDITIONAL=
    "if" pl HYPER_EXP pr BLOCK [ "else" BLOCK ]
.

WHILE=
    "while" pl HYPER_EXP pr BLOCK
.

FOR=
    "for" pl ASSIGN semicolon HYPER_EXP semicolon ASSIGN pr BLOCK
.

FUNC_CALL	(. string name; .)
=
    IDENT	< out name > 
    pl [ EXP { comma EXP } ] pr semicolon
.
/*
METHOD_CALL=
    IDENT dot IDENT { dot IDENT } pl [ EXP { comma EXP } ] pr semicolon
.
*/
TERM=
    FACT                    (. check(sTable, TERM_OPERATORS); .)
    { ( mul (. stackOperator.Push(_mul); .) | div (. stackOperator.Push(_div); .) ) FACT }
.

SHORT_ASSIGN=
    sadd | ssub | smul | sdiv
.

VARIABLE_ASSIGN   (. string name; .)
=
    IDENT	< out name > 
    [ /*( dot IDENT { dot IDENT } ) |*/ ( bl EXP br [ bl EXP br ] ) ]
.

VARIABLE_FACT	(. string name; .)
=
    IDENT	< out name >            (. stackOperand.Push(name); .)
    [ ( bl EXP br [ bl EXP br ] ) | /*( dot IDENT pl [ EXP { comma EXP } ] pr ) | */( pl [ EXP { comma EXP } ] pr ) ]
.

HYPER_EXP=
    SUPER_EXP { REL_EXP SUPER_EXP }
.

BLOCK=
    cbl { STATUTE } cbr
.

FACT
=
    ( pl (. stackOperator.Push(_pl); .)  EXP pr (. stackOperator.Pop(); .) )                                                  |
    ( [ ( "+" | "-" ) ] ( cte_I  (. stackOperand.Push(createTempInt(Int32.Parse(t.val), sTable)); .) | cte_F (. stackOperand.Push(createTempFloat(float.Parse(t.val), sTable)); .)) )         |
    ( ctr_Str  (. stackOperand.Push(createTempString(t.val, sTable)); .))                                     |
    ( VARIABLE_FACT )
.

STEP=
    increment | decrement
.

REL_EXP=
    "and"   |   "&&"    |
    "or"    |   "||"
.

SUPER_EXP=
    EXP                 (. check(sTable, RELOP_OPERATORS); .)
    [ REL_OP EXP ]
.

REL_OP=
    ( greater   (. stackOperator.Push(_greater); .)     | less (. stackOperator.Push(_less); .) )          |
    ( greatereq (. stackOperator.Push(_greatereq); .)   | lesseq (. stackOperator.Push(_lesseq); .) ) |
    ( equaleq   (. stackOperator.Push(_equaleq); .)     | different (. stackOperator.Push(_different); .))
.

IDENT       < out string name >
=
    id      (. name = t.val; .)
.

END PROGRAM.
