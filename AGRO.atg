using System;
using Newtonsoft.Json;
using AGRO_GRAMM;
using System.Collections.Generic;


COMPILER PROGRAM

const int // types
	  invalid = Int32.MaxValue, undef = 0, t_int = 1, t_float = 2, t_char = 3, t_void = 4 ,t_obj = 5, t_string = 6;

const int // object kinds
	  var = 0, func = 1, temporal = 2;


int[] TERM_OPERATORS = { _mul, _div };
int[] EXP_OPERATORS = { _add, _sub };
int[] RELEXP_OPERATORS = { _and, _or };
int[] RELOP_OPERATORS = { _greater, _less, _greatereq, _lesseq, _equaleq, _different };

//print token
public const int _print=66;
public const int _input=77;

Dictionary<int, string> operandInts = JsonConvert.DeserializeObject<Dictionary<int, string>>(@$"{{
				{_add}:'+',
				{_sub}:'-',
				{_div}:'/',
				{_mul}:'*',
				{_sadd}:'+=',
				{_ssub}:'-=',
				{_sdiv}:'/=',
				{_smul}:'*=',
				{_increment}: '++',
				{_decrement}: '--',
				{_less}:'<',
				{_lesseq}:'<=',
				{_greater}:'>',
				{_greatereq}:'>=',
				{_equaleq}:'==',
				{_equal}:'=',
				{_different}:'!=',
				{_and}:'&&',
				{_and}:'and',
				{_or}:'or',
				{_or}:'||',
                {_print}: 'print',
                {_input}: 'input'
				}}");

Dictionary<int, string> typesInts = JsonConvert.DeserializeObject<Dictionary<int, string>>(@$"{{
				{invalid}: 'INVALID',
                {undef}:'UNDEFINED',
				{t_int}:'INT',
				{t_float}:'FLOAT',
				{t_char}:'CHAR',
				{t_void}:'VOID',
				{t_obj}:'OBJ',
				{t_string}:'STRING'
				}}");

SymbolTable   sTable;

Stack<String> stackOperand = new Stack<String>();
Stack<int>   stackOperator = new Stack<int>();
Stack<int>      stackTypes = new Stack<int>();
Stack<int>      stackJumps = new Stack<int>();

int tempCont = 0;

public List<Actions> program = new List<Actions>();

void pushToOperandStack(string id, SymbolTable st){
    // In order to push to the stack, we need to know the type of the id
    int typeId = st.getType(id);
    // Push the id
    stackOperand.Push(id);
    // Push the type
    stackTypes.Push(typeId);

}

string createTempInt(int tempp, SymbolTable st){
    string tempName;
    tempName = "_t" + tempCont;
    tempCont+=1;
    st.putSymbol(tempName, t_int, temporal);
    return tempName;
}

string createTempFloat(float tempp, SymbolTable st){
    string tempName;
    tempName = "_t" + tempCont;
    tempCont+=1;
    st.putSymbol(tempName, t_float, temporal);
    return tempName;
}

string createTempString(string tempp, SymbolTable st){
    string tempName;
    tempName = "_t" + tempCont;
    tempCont+=1;
    st.putSymbol(tempName, t_string, temporal);
    return tempName;
}

void checkAssign(SymbolTable st) {
    string leftOper;
    string rightOper;
    int leftType;
    int rightType;
    int operat;

    if(stackOperator.Count > 0) {
        // Get the data to create the quad
        rightType = stackTypes.Pop();
        rightOper = stackOperand.Pop();

        if (stackOperand.Count > 0) {
            leftType = stackTypes.Pop();
            leftOper = stackOperand.Pop();
        }
        else {
            leftType = rightType;
            leftOper = rightOper;
        }
        
        operat = stackOperator.Pop();
        
        Cuadruple quad = new Cuadruple(operat, leftOper, rightOper, leftOper, st, operandInts);

        // Check if cube operator is valid for these operands
        if (quad.typeOut == invalid)
        {
            SemErr("Invalid assignment: " + typesInts[leftType] + " " + operandInts[operat] + " " + typesInts[rightType]);
        }
        program.Add(quad);
    }
}

void check(SymbolTable st, int[] arr){
    string leftOper;
    string rightOper;
    int leftType;
    int rightType;
    int operat;
    string tempName;
    if(stackOperator.Count > 0){
        if(Array.Exists(arr, s => s.Equals(stackOperator.Peek()) )){
            // Get the data to create the quad
            rightType = stackTypes.Pop();
            rightOper = stackOperand.Pop();
            leftType = stackTypes.Pop();
            leftOper = stackOperand.Pop();
            operat = stackOperator.Pop();
            // Create the temporal variable
            tempName = "_t" + tempCont;
            tempCont+=1;
            Cuadruple quad = new Cuadruple(operat, leftOper, rightOper, tempName, st, operandInts);

            // Check if cube operator is valid for these operands
            if (quad.typeOut == invalid)
            {
                SemErr("Invalid operation: " + typesInts[leftType] + " " + operandInts[operat] + " " + typesInts[rightType]);
            }
            st.putSymbol(tempName, quad.typeOut, temporal);
            program.Add(quad);
            pushToOperandStack(tempName, st);
        }
    }
}

void checkInputOutput(SymbolTable st, int oper){
    string operand;
    int type;

    type = stackTypes.Pop();
    operand = stackOperand.Pop();
    Cuadruple quad = new Cuadruple(oper, operand, operand, operand, st, operandInts);
    program.Add(quad);
}


/*--------------------------------------------------------------------------*/    

bool IsFunctionCall(){
    scanner.ResetPeek();
    Token x = la; 
    while (x.kind == _id ) 
        x = scanner.Peek();
    return x.kind == _pl;
}

bool IsMethodCall() { 
    scanner.ResetPeek();
    Token x = la; 
    while (x.kind == _id || x.kind == _dot) 
        x = scanner.Peek();
    return x.kind == _pl;
} 

bool IsTypeFunction() {
    scanner.ResetPeek();
    Token next = scanner.Peek();
    next = scanner.Peek();
    return next.kind == _pl;
}

bool IsDecVars(){
    scanner.ResetPeek();
    Token x = scanner.Peek();
    while (x.kind == _id || x.kind == _comma) 
        x = scanner.Peek();
    return x.kind == _semicolon;
}

CHARACTERS

letter		= 'A'..'Z' + 'a'..'z'.
digit		= '0'..'9'.
tab			= '\t'.
cr			= '\r'.
lf			= '\n'.
newLine		= cr + lf.
notQuote	= ANY - '"' - "\r\n".

TOKENS

id			= letter { letter | digit }.
cte_I		= digit { digit }.
cte_F		= digit { digit } "." digit { digit }.
ctr_Str 	= '"' {notQuote} '"'.
cbl         = "{".
cbr         = "}".
bl          = "[".
br          = "]".
pl          = "(".
pr          = ")".
comma       = ",".
semicolon   = ";".
add         = "+".
sub         = "-".
mul         = "*".
div         = "/".
equal       = "=".
dot         = ".".
sadd        = "+=".
ssub        = "-=".
sdiv        = "/=".
smul        = "*=".
increment   = "++".
decrement   = "--".
colon       = ":".
less        = "<".
greater     = ">".
lesseq      = "<=".
greatereq   = ">=".
equaleq     = "==".
different   = "!=".
and         = "&&".
or          = "||".

COMMENTS FROM "%%" TO "\r\n"

IGNORE tab + cr + lf

PRODUCTIONS

PROGRAM= 
    (.
     sTable = new SymbolTable();
    .)
    { DECLARATION } MAIN
    
.

DECLARATION=
    
    IF( IsTypeFunction() ) DEC_FUNC | DEC_VARS //| DEC_CLASS
.

DEC_VARS                                    (. string name; int type; string className; .)
=
    ( IDENT		    < out className >
    IDENT                   < out name >    (. sTable.putSymbol(name, t_obj, var); .)
    { comma IDENT           < out name >    (. sTable.putSymbol(name, t_obj, var); .)   
    } semicolon ) |
    ( 
     SIMPLE_TYPE            < out type >
     IDENT                  < out name >    (. sTable.putSymbol(name, type, var); .)
     [ bl cte_I br [ bl cte_I br ] ] 
     { comma IDENT         < out name >     (. sTable.putSymbol(name, type, var); .)
     [ bl cte_I br [ bl cte_I br ] ] } 
     semicolon 
    )
.

DEC_FUNC				(. string name; int type; .)
=				
    TYPE_FUNC			< out type >
    IDENT			< out name > (. sTable.putSymbol(name, type, func);
                                    sTable = sTable.newChildSymbolTable(); .)
    pl [ PARAMS_FUNC ] pr
    cbl [
     ( IF( IsDecVars() ) DEC_VARS |
      STATUTE ) 
      { ( IF( IsDecVars() ) DEC_VARS |
       STATUTE ) } ] 
     [ RETURN ] 
    cbr					(. sTable = sTable.parentSymbolTable; .)
.
/*
DEC_CLASS=
    "class" IDENT
    [ colon IDENT ] 
    cbl { CLASS_DEF } cbr
.

COMPOUND_TYPE  < out int typeObj >  (. string type; .) 
=
    IDENT       < out type >	(. typeObj = t_obj; .)
.
*/
SIMPLE_TYPE         < out int type >
=                   (. type = undef; .) 
    (
    "int"           (. type = t_int; .)   |
    "float"         (. type = t_float; .) |
    "char"          (. type = t_char; .)
    )
.

MAIN=               (. sTable = sTable.newChildSymbolTable(); .)
    "main" cbl ( IF( IsDecVars() ) DEC_VARS | STATUTE ) { IF( IsDecVars() ) DEC_VARS | STATUTE } cbr
                    (. sTable = sTable.parentSymbolTable; .)
.

STATUTE=
    INPUT       |
    PRINT       |
    IF( IsFunctionCall() ) FUNC_CALL  |
 //   IF( IsMethodCall() ) METHOD_CALL  |
    CONDITIONAL |
    WHILE       |
    FOR         |
    ASSIGN      
.

TYPE_FUNC           < out int type >
=                   (. type = undef; .)
    (
        "int"       (. type = t_int; .)     | 
        "float"     (. type = t_float; .)   |
        "char"      (. type = t_char; .)    |
        "void"      (. type = t_void; .)
    )
.

PARAMS_FUNC             		(. string name; int type; .)
=
    SIMPLE_TYPE         < out type >
    IDENT		< out name >	(. sTable.putSymbol(name, type, var); .)
    { 
     comma SIMPLE_TYPE	< out type >
     IDENT		< out name >	(. sTable.putSymbol(name, type, var); .)
    }
.

RETURN=
    "return" HYPER_EXP semicolon
.

EXP=
    TERM                    
    { (add (. stackOperator.Push(_add); .) | sub (. stackOperator.Push(_sub);.) ) TERM }
    (. check(sTable, EXP_OPERATORS); .)
.
/*
CLASS_DEF=
    ( "+" | "-" ) ( IF( IsTypeFunction() ) DEC_FUNC | DEC_VARS )
.
*/
ASSIGN=
    VARIABLE_ASSIGN ( ( ( SHORT_ASSIGN | equal (. stackOperator.Push(_equal); .) ) HYPER_EXP ) | STEP ) semicolon (. checkAssign(sTable); .)
.

INPUT=
    "input" pl VARIABLE_ASSIGN (. checkInputOutput(sTable, _input); .) pr semicolon
.

PRINT=
    "print" pl 
    HYPER_EXP (. checkInputOutput(sTable, _print); .) { comma HYPER_EXP (. checkInputOutput(sTable, _print); .) }
    pr semicolon
.

CONDITIONAL=
    "if" pl HYPER_EXP pr BLOCK [ "else" BLOCK ]
.

WHILE=
    "while" pl HYPER_EXP pr BLOCK
.

FOR=
    "for" pl ASSIGN semicolon HYPER_EXP semicolon ASSIGN pr BLOCK
.

FUNC_CALL	(. string name; .)
=
    IDENT	< out name > 
    pl [ EXP { comma EXP } ] pr semicolon
.
/*
METHOD_CALL=
    IDENT dot IDENT { dot IDENT } pl [ EXP { comma EXP } ] pr semicolon
.
*/
TERM=
    FACT
    { ( mul (. stackOperator.Push(_mul); .) | div (. stackOperator.Push(_div); .) ) FACT }
    (. check(sTable, TERM_OPERATORS); .)
.

SHORT_ASSIGN=
    sadd (. stackOperator.Push(_sadd); .) | ssub (. stackOperator.Push(_ssub); .) | smul (. stackOperator.Push(_smul); .) | sdiv (. stackOperator.Push(_sdiv); .)
.

VARIABLE_ASSIGN   (. string name; .)
=
    IDENT	< out name > (. pushToOperandStack(name, sTable); .)
    [ /*( dot IDENT { dot IDENT } ) |*/ ( bl EXP br [ bl EXP br ] ) ]
.

VARIABLE_FACT	(. string name; .)
=
    IDENT	< out name >            (. pushToOperandStack(name, sTable); .)
    [ ( bl EXP br [ bl EXP br ] ) | /*( dot IDENT pl [ EXP { comma EXP } ] pr ) | */( pl [ EXP { comma EXP } ] pr ) ]
.

HYPER_EXP=
    SUPER_EXP { REL_EXP SUPER_EXP }
    (. check(sTable, RELEXP_OPERATORS); .)
.

BLOCK=
    cbl { STATUTE } cbr
.

FACT
=
    ( pl (. stackOperator.Push(_pl); .)  HYPER_EXP pr (. stackOperator.Pop(); .) )                                                  |
    ( [ ( "+" | "-" ) ] ( cte_I  (. pushToOperandStack(createTempInt(Int32.Parse(t.val), sTable), sTable); .) | cte_F (. pushToOperandStack(createTempFloat(float.Parse(t.val), sTable), sTable); .)) )         |
    ( ctr_Str  (. pushToOperandStack(createTempString(t.val, sTable), sTable); .))                                     |
    ( VARIABLE_FACT )
.

STEP=
    increment (. stackOperator.Push(_increment); .) | decrement (. stackOperator.Push(_decrement); .)
.

REL_EXP=
    "and"   (. stackOperator.Push(_and); .)|   "&&"    (. stackOperator.Push(_and); .)|
    "or"    (. stackOperator.Push(_or); .)|   "||"    (. stackOperator.Push(_or); .)
.

SUPER_EXP=
    EXP     { REL_OP EXP }
    (. check(sTable, RELOP_OPERATORS); .)
.

REL_OP=
    ( greater   (. stackOperator.Push(_greater); .)     | less (. stackOperator.Push(_less); .) )          |
    ( greatereq (. stackOperator.Push(_greatereq); .)   | lesseq (. stackOperator.Push(_lesseq); .) ) |
    ( equaleq   (. stackOperator.Push(_equaleq); .)     | different (. stackOperator.Push(_different); .))
.

IDENT       < out string name >
=
    id      (. name = t.val; .)
.

END PROGRAM.
